cayley_table(G,m) := makelist(makelist(m(g,h),h,G),g,G);

cayley_table_tex(G,m,texfun,opname) := block([H,T],
    H : cons(opname,map(texfun,G)),
    T : cons(H,makelist(cons(texfun(g),makelist(texfun(m(g,h)),h,G)),g,G)),
    return(lined_array_tex(T))
);

word_reduce(w) := block([u,v,ok,x,l,m],
 v : makelist(if listp(x) then x else [x,1],x,w),
 ok : false,
 while not(ok) do (
  ok : true,
  u : [],
  for x in v do (
   l : length(u),
   if l > 0 and first(x) = first(last(u)) then (
    ok : false,
    m : last(x) + last(last(u)),
    u : firstn(u,l-1),
    if not(m = 0) then u : append(u,[[first(x),m]])    
   ) else (
    u : append(u,[x])
   )
  ),
  v : u
 ),
 u : makelist(if last(x) = 1 then first(x) else x,x,u),
 return(u)
);

word_reduce_abelian(w) := block(
 v : sort(makelist(if listp(x) then x else [x,1],x,w)),
 return(word_reduce(v))
);

word_id : [];

word_prod([u]) := word_reduce(apply(append,u));

word_inv(w) := block([v],
 v : makelist(if listp(x) then x else [x,1],x,w),
 v : reverse(v),
 v : makelist([first(x),-last(x)],x,v),
 return(word_reduce(v))
);

word_tex(w) := block([v],
  v : makelist(if listp(x) then x else [x,1],x,w),
  v : makelist(if (last(x) = 1) then string(first(x)) else sconcat(string(first(x)),"^{",last(x),"}"),x,v),
  return(simplode(v,""))
);

word_tex0(w) := sconcat("\\(",word_tex(w),"\\)");

dihedralp(x) := ev(subvarp(x) and (op(x) = r or op(x) = s) and length(args(x)) = 1 and integerp(args(x)[1]),pred);
dihedral_rotp(x) := ev(dihedralp(x) and op(x) = r,pred);
dihedral_refp(x) := ev(dihedralp(x) and op(x) = s,pred);
dihedral_sgn(x) := if op(x) = s then -1 else 1;

dihedral_reducedp_aux(n,x) := 
 ev(dihedralp(x) and args(x)[1] >= 0 and args(x)[1] < n,pred);

dihedral_id(n) := r[0];

dihedral_inv_aux(n,x) := block([k],
 if not(dihedralp(x)) then error("argument is not dihedral"),
 k : args(x)[1],
 if op(x) = s then return(s[mod(k,n)]) else return(r[mod(-k,n)])
);

dihedral_prod_aux(n,[u]) := block([m,x,y,k,l],
 m : length(u),
 if m = 0 then (
  return(dihedral_id(n))
 ) else (
  x : u[1],
  if not(dihedralp(x)) then error("argument is not dihedral",x),
  k : mod(args(x)[1],n),
  x : apply(op(x),[k]),
  if m = 1 then (
   return(x)
  ) else (
   y : apply(dihedral_prod_aux,cons(n,rest(u))),
   l : args(y)[1],
   if op(x) = r then (
    if op(y) = r then return(r[mod(k+l,n)]) else return(s[mod(k+l,n)])
   ) else (
    if op(y) = r then return(s[mod(k-l,n)]) else return(r[mod(k-l,n)])
   )
  )
 )
);

dihedral_reducedp(n) := buildq([n0 : n],lambda([u],dihedral_reducedp_aux(n0,u))); 
dihedral_inv(n) := buildq([n0 : n],lambda([u],dihedral_inv_aux(n0,u)));
dihedral_prod(n) := buildq([n0 : n],lambda([[u]],apply(dihedral_prod_aux,cons(n0,u))));

dihedral_elems(n) := append(makelist(r[i],i,0,n-1),makelist(s[i],i,0,n-1));

